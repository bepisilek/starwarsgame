<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sea Wave Simulator</title>
  <style>
    html, body { height: 100%; margin: 0; background: #03040a; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
    .hud{
      position: fixed; left: 14px; top: 12px; z-index: 5;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.82);
      text-shadow: 0 1px 12px rgba(0,0,0,0.6);
      user-select: none; pointer-events: none;
      line-height: 1.35;
    }
    .hud b{ color: rgba(255,255,255,0.95); }
    .hint{
      position: fixed; right: 14px; bottom: 12px; z-index: 5;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.78);
      text-shadow: 0 1px 12px rgba(0,0,0,0.6);
      user-select: none; pointer-events: none;
      text-align: right;
    }
    .badge{
      display:inline-block; padding: 6px 10px; border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="badge"><b>Sea Wave Simulator</b> Â· WebGL</div><br />
    <div class="badge">Drag to steer wind, scroll to zoom, space to pause</div>
  </div>
  <div class="hint">
    <div class="badge">Tip: click and drag for bigger swells</div>
  </div>
  <canvas id="c"></canvas>

  <script>
    (() => {
      const canvas = document.getElementById("c");
      /** @type {WebGLRenderingContext} */
      const gl = canvas.getContext("webgl", { antialias: true, alpha: false, premultipliedAlpha: false });

      if (!gl) {
        document.body.innerHTML = "<div style='color:#fff;font-family:system-ui;padding:20px'>WebGL not supported in this browser.</div>";
        return;
      }

      const vsSource = `
        attribute vec2 aPos;
        varying vec2 vUv;
        void main(){
          vUv = aPos * 0.5 + 0.5;
          gl_Position = vec4(aPos, 0.0, 1.0);
        }
      `;

      const fsSource = `
        precision highp float;
        varying vec2 vUv;

        uniform vec2  uRes;
        uniform float uTime;
        uniform vec2  uMouse;
        uniform float uDown;
        uniform float uZoom;
        uniform float uPause;

        // Hash, noise, fbm
        float hash21(vec2 p){
          p = fract(p*vec2(123.34, 456.21));
          p += dot(p, p+45.32);
          return fract(p.x*p.y);
        }

        float noise2(vec2 p){
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash21(i);
          float b = hash21(i + vec2(1.0, 0.0));
          float c = hash21(i + vec2(0.0, 1.0));
          float d = hash21(i + vec2(1.0, 1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a, b, u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
        }

        float fbm(vec2 p){
          float v = 0.0;
          float a = 0.5;
          mat2 m = mat2(1.6, -1.2, 1.2, 1.6);
          for(int i=0;i<6;i++){
            v += a * noise2(p);
            p = m * p;
            a *= 0.52;
          }
          return v;
        }

        // Gerstner wave stack for crisp crests
        vec2 gerstner(vec2 p, vec2 dir, float steep, float amp, float freq, float speed, float t){
          float d = dot(dir, p);
          float ph = d * freq + t * speed;
          float s = sin(ph);
          float c = cos(ph);
          return vec2(dir.x * (steep*amp*c), dir.y * (steep*amp*c)) + vec2(-dir.y, dir.x) * 0.0;
        }

        float waveHeight(vec2 p, vec2 wind, float t){
          // multi-directional swells + choppy noise details
          float h = 0.0;

          vec2 d1 = normalize(wind);
          vec2 d2 = normalize(vec2(-wind.y, wind.x));
          vec2 d3 = normalize(d1*0.6 + d2*0.8);
          vec2 d4 = normalize(d1*0.85 - d2*0.35);

          float w1 = sin(dot(p, d1) * 1.25 + t*0.85);
          float w2 = sin(dot(p, d2) * 1.90 + t*1.15);
          float w3 = sin(dot(p, d3) * 2.70 + t*1.55);
          float w4 = sin(dot(p, d4) * 3.80 + t*2.05);

          h += 0.55*w1 + 0.28*w2 + 0.16*w3 + 0.10*w4;

          // micro ripples
          float n = fbm(p*3.0 + t*0.6);
          h += (n-0.5) * 0.22;

          // sharpen crests
          float ch = abs(h);
          h += (ch*ch*ch) * 0.12 * sign(h);

          return h;
        }

        vec3 skyColor(vec3 rd){
          // simple atmospheric sky gradient + sun glow
          float t = clamp(rd.y*0.5+0.5, 0.0, 1.0);
          vec3 top = vec3(0.04, 0.11, 0.24);
          vec3 mid = vec3(0.02, 0.06, 0.15);
          vec3 hor = vec3(0.02, 0.03, 0.06);
          vec3 col = mix(hor, mix(mid, top, smoothstep(0.15, 1.0, t)), t);

          vec3 sunDir = normalize(vec3(-0.28, 0.22, 0.93));
          float s = max(dot(rd, sunDir), 0.0);
          float glow = pow(s, 120.0) + 0.25*pow(s, 12.0);
          col += vec3(1.0, 0.85, 0.55) * glow * 0.9;
          return col;
        }

        void main(){
          // Normalized coordinates
          vec2 frag = vUv * uRes;
          vec2 uv = (frag - 0.5*uRes) / uRes.y;

          float time = mix(uTime, uPause, step(0.5, 0.0)); // keep compiler calm
          time = (uPause > 0.5) ? uPause : uTime;

          // Camera
          float zoom = uZoom;
          vec3 ro = vec3(0.0, 1.35, -2.25/zoom);
          vec3 ta = vec3(0.0, 0.05, 0.0);

          // Mouse influences wind direction and swell energy
          vec2 m = uMouse;
          vec2 wind = normalize(vec2(m.x, m.y) + vec2(0.001, 0.0));
          float energy = mix(0.85, 1.35, clamp(uDown, 0.0, 1.0)); // dragging increases swell

          // Build ray direction
          vec3 ww = normalize(ta - ro);
          vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));
          vec3 vv = cross(ww, uu);
          vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.6*ww);

          // Intersect with dynamic water surface using simple raymarch on heightfield
          float t = 0.0;
          float tMax = 10.0;
          float hit = 0.0;

          // We solve for y = waterHeight(xz)
          for(int i=0;i<80;i++){
            vec3 p = ro + rd*t;
            vec2 xz = p.xz;

            // scale world
            vec2 wp = xz * 1.15 * zoom;
            float h = waveHeight(wp, wind, time*0.9) * 0.35 * energy;

            float d = p.y - h; // signed distance-ish to surface
            if(d < 0.001){
              hit = 1.0;
              break;
            }
            t += d * 0.72;
            if(t > tMax) break;
          }

          vec3 col;

          if(hit < 0.5){
            // sky
            col = skyColor(rd);

            // subtle horizon mist
            float haze = exp(-max(rd.y, 0.0)*6.0);
            col = mix(col, vec3(0.02, 0.04, 0.07), (1.0-haze)*0.25);
          } else {
            // hit point
            vec3 p = ro + rd*t;
            vec2 xz = p.xz;
            vec2 wp = xz * 1.15 * zoom;

            float h0 = waveHeight(wp, wind, time*0.9) * 0.35 * energy;
            // Surface normal from finite differences
            float e = 0.0035;
            float hx = waveHeight(wp + vec2(e,0.0), wind, time*0.9) * 0.35 * energy;
            float hz = waveHeight(wp + vec2(0.0,e), wind, time*0.9) * 0.35 * energy;
            vec3 n = normalize(vec3(h0 - hx, e, h0 - hz));

            // Fresnel
            float fres = pow(1.0 - clamp(dot(n, -rd), 0.0, 1.0), 5.0);
            fres = mix(0.03, 1.0, fres);

            // Reflection
            vec3 r = reflect(rd, n);
            vec3 refl = skyColor(r);

            // Water body color with depth approximation
            float depth = clamp(t / tMax, 0.0, 1.0);
            vec3 deep = vec3(0.02, 0.18, 0.22);
            vec3 shallow = vec3(0.05, 0.35, 0.32);
            vec3 water = mix(shallow, deep, smoothstep(0.1, 0.95, depth));

            // Sun specular
            vec3 sunDir = normalize(vec3(-0.28, 0.22, 0.93));
            vec3 hV = normalize(-rd + sunDir);
            float spec = pow(max(dot(n, hV), 0.0), 240.0) * 1.3;
            spec += pow(max(dot(n, hV), 0.0), 32.0) * 0.08;

            // Foam on crests
            float crest = clamp(abs(h0) * 2.4, 0.0, 1.0);
            float foamNoise = fbm(wp*5.5 + time*0.7);
            float foam = smoothstep(0.55, 1.0, crest + (foamNoise-0.5)*0.35);
            foam *= smoothstep(0.0, 0.25, depth) * 0.9;

            // Subsurface sparkle
            float spark = pow(max(0.0, 1.0 - dot(n, vec3(0.0,1.0,0.0))), 2.0) * 0.12;
            spark *= (0.5 + 0.5*sin(40.0*wp.x + time*2.0) * sin(40.0*wp.y - time*1.8));

            // Mix
            col = mix(water, refl, fres);
            col += vec3(1.0, 0.9, 0.75) * spec;
            col = mix(col, vec3(0.92, 0.97, 1.0), foam*0.75);
            col += vec3(0.12, 0.30, 0.35) * spark;

            // Horizon fog over water
            float fog = 1.0 - exp(-t*0.18);
            col = mix(col, vec3(0.02, 0.04, 0.07), fog*0.38);
          }

          // Subtle vignette and filmic curve
          vec2 q = vUv - 0.5;
          float vig = smoothstep(0.95, 0.25, dot(q,q));
          col *= 0.92 + 0.08*vig;

          // Filmic-ish tonemap
          col = max(col, 0.0);
          col = (col*(2.51*col + 0.03)) / (col*(2.43*col + 0.59) + 0.14);

          gl_FragColor = vec4(col, 1.0);
        }
      `;

      function compile(type, src) {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
          const err = gl.getShaderInfoLog(sh);
          gl.deleteShader(sh);
          throw new Error(err || "Shader compile failed");
        }
        return sh;
      }

      function link(vs, fs) {
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          const err = gl.getProgramInfoLog(prog);
          gl.deleteProgram(prog);
          throw new Error(err || "Program link failed");
        }
        return prog;
      }

      const vs = compile(gl.VERTEX_SHADER, vsSource);
      const fs = compile(gl.FRAGMENT_SHADER, fsSource);
      const prog = link(vs, fs);

      const aPos = gl.getAttribLocation(prog, "aPos");
      const uRes  = gl.getUniformLocation(prog, "uRes");
      const uTime = gl.getUniformLocation(prog, "uTime");
      const uMouse= gl.getUniformLocation(prog, "uMouse");
      const uDown = gl.getUniformLocation(prog, "uDown");
      const uZoom = gl.getUniformLocation(prog, "uZoom");
      const uPause= gl.getUniformLocation(prog, "uPause");

      // Fullscreen quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1,  1,-1, -1, 1,
        -1, 1,  1,-1,  1, 1
      ]), gl.STATIC_DRAW);

      let dpr = Math.min(2, window.devicePixelRatio || 1);
      function resize() {
        dpr = Math.min(2, window.devicePixelRatio || 1);
        const w = Math.floor(innerWidth * dpr);
        const h = Math.floor(innerHeight * dpr);
        canvas.width = w;
        canvas.height = h;
        gl.viewport(0, 0, w, h);
      }
      addEventListener("resize", resize, { passive: true });
      resize();

      // Interaction
      let mouse = { x: 0.15, y: 0.65 };
      let down = 0;
      let zoom = 1.0;
      let paused = false;
      let pauseTime = 0;

      function setMouseFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;

        // map to a nice wind vector space
        const vx = (x - 0.5) * 2.0;
        const vy = (0.5 - y) * 2.0;
        const len = Math.hypot(vx, vy) || 1;
        mouse.x = vx / len;
        mouse.y = vy / len;
      }

      canvas.addEventListener("pointerdown", (e) => {
        down = 1;
        canvas.setPointerCapture(e.pointerId);
        setMouseFromEvent(e);
      }, { passive: true });

      canvas.addEventListener("pointermove", (e) => {
        setMouseFromEvent(e);
      }, { passive: true });

      canvas.addEventListener("pointerup", () => { down = 0; }, { passive: true });
      canvas.addEventListener("pointercancel", () => { down = 0; }, { passive: true });

      addEventListener("wheel", (e) => {
        const delta = Math.sign(e.deltaY);
        zoom *= (delta > 0 ? 0.92 : 1.08);
        zoom = Math.max(0.6, Math.min(1.8, zoom));
      }, { passive: true });

      addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          paused = !paused;
          if (paused) pauseTime = lastT;
        }
        if (e.key === "r" || e.key === "R") {
          zoom = 1.0;
          mouse = { x: 0.15, y: 0.65 };
        }
      });

      gl.useProgram(prog);
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      gl.disable(gl.DEPTH_TEST);

      let start = performance.now();
      let lastT = 0;

      function frame(now) {
        const t = (now - start) / 1000;
        lastT = paused ? pauseTime : t;

        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform1f(uTime, lastT);
        gl.uniform2f(uMouse, mouse.x, mouse.y);
        gl.uniform1f(uDown, down);
        gl.uniform1f(uZoom, zoom);
        gl.uniform1f(uPause, paused ? 1.0 : 0.0);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
