<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#1a4d6d">
  <meta name="description" content="Build defenses and survive the tsunami waves!">
  <title>Tsunami Defense - Wave Survival Game</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA0klEQVRYhe2WQQqDMBBFn8VLuPIGHsOjuBEvYL2Bx3DlJdx0UQgUJBqTmUkXhf5VyJ/3STIRERERERERERERP4EBV+AJzMADWIA7cAJagF9tAhpgA06q7cAA+MCGGnCtjdcAJ+DZ2ngNcALuqu3AAPjAhhpwrY3XACfg2dp4DXACHqrtwAD4wIYacK2N1wAn4NnaeA1wAu6q7cAA+MCGGnCtjdcAJ+DZ2ngNcAIequ3AAPjAhhpwrY3XACfg2dp4DXAC7qrtwAD4wIYacK2N1wDnr4gIIiK+yhtSVyUsZ0HqswAAAABJRU5ErkJggg==">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(180deg, #1a4d6d 0%, #0a1f2e 100%);
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #87ceeb;
      image-rendering: crisp-edges;
      image-rendering: pixelated;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 10px;
    }

    .stat-box {
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      font-size: 14px;
      font-weight: bold;
    }

    .stat-label {
      font-size: 11px;
      opacity: 0.8;
      font-weight: normal;
    }

    .stat-value {
      font-size: 18px;
      color: #4ecdc4;
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      pointer-events: all;
    }

    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      pointer-events: all;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.primary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .btn.success {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .btn.danger {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(20px);
      padding: 40px;
      border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
      color: white;
      min-width: 300px;
      max-width: 500px;
      pointer-events: all;
      z-index: 100;
    }

    .menu h1 {
      font-size: 32px;
      margin-bottom: 20px;
      text-align: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .menu h2 {
      font-size: 24px;
      margin-bottom: 15px;
      text-align: center;
    }

    .menu p {
      margin: 10px 0;
      line-height: 1.6;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .shop-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s;
    }

    .shop-item:hover {
      border-color: #4ecdc4;
      background: rgba(255, 255, 255, 0.15);
    }

    .shop-item h3 {
      font-size: 16px;
      margin-bottom: 8px;
      color: #4ecdc4;
    }

    .shop-item p {
      font-size: 12px;
      margin: 5px 0;
      opacity: 0.9;
    }

    .hidden {
      display: none !important;
    }

    .wave-warning {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 50, 50, 0.9);
      color: white;
      padding: 30px 50px;
      border-radius: 12px;
      font-size: 36px;
      font-weight: bold;
      animation: pulse 1s ease-in-out infinite;
      box-shadow: 0 10px 40px rgba(255, 0, 0, 0.5);
    }

    @keyframes pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.05); }
    }

    .help-text {
      font-size: 12px;
      opacity: 0.7;
      margin-top: 15px;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui-overlay">
    <div class="hud">
      <div class="stat-box">
        <div class="stat-label">Level</div>
        <div class="stat-value" id="levelDisplay">1</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">üí∞ Coins</div>
        <div class="stat-value" id="coinsDisplay">500</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">üè† City HP</div>
        <div class="stat-value" id="cityHpDisplay">100</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">üåä Wave</div>
        <div class="stat-value" id="waveDisplay">Preparing...</div>
      </div>
    </div>

    <div class="controls">
      <button class="btn success" id="shopBtn">üõí Shop</button>
      <button class="btn primary" id="startWaveBtn">üåä Start Wave</button>
      <button class="btn" id="pauseBtn">‚è∏ Pause</button>
      <button class="btn danger" id="resetBtn">üîÑ Reset</button>
    </div>

    <div id="waveWarning" class="wave-warning hidden">
      ‚ö†Ô∏è TSUNAMI INCOMING! ‚ö†Ô∏è
    </div>
  </div>

  <!-- Main Menu -->
  <div id="mainMenu" class="menu">
    <h1>üåä TSUNAMI DEFENSE üåä</h1>
    <p style="text-align: center; margin: 20px 0;">
      Build defenses to protect your coastal city from devastating tsunami waves!
    </p>
    <p style="text-align: center; opacity: 0.8; font-size: 14px;">
      Click on the terrain to build walls and barriers. Each level brings bigger waves!
    </p>
    <div class="menu-buttons">
      <button class="btn primary" id="startGameBtn">üéÆ Start Game</button>
      <button class="btn" id="howToPlayBtn">üìñ How to Play</button>
    </div>
  </div>

  <!-- How to Play Menu -->
  <div id="howToPlayMenu" class="menu hidden">
    <h2>üìñ How to Play</h2>
    <p><strong>Objective:</strong> Protect your city from tsunami waves!</p>
    <p><strong>Building:</strong> Click on the ground to place defenses</p>
    <p><strong>Defenses:</strong></p>
    <ul style="margin-left: 20px; line-height: 1.8;">
      <li>üß± Basic Wall: 100 coins - Small barrier</li>
      <li>üè∞ Strong Wall: 250 coins - Taller, more durable</li>
      <li>üóø Mega Barrier: 500 coins - Maximum protection</li>
      <li>üå≥ Tree: 50 coins - Slows water flow</li>
    </ul>
    <p><strong>Strategy:</strong> Build layered defenses and upgrade between waves!</p>
    <div class="menu-buttons">
      <button class="btn" id="backToMainBtn">‚Üê Back</button>
    </div>
  </div>

  <!-- Shop Menu -->
  <div id="shopMenu" class="menu hidden">
    <h2>üõí Defense Shop</h2>
    <div class="shop-grid">
      <div class="shop-item">
        <h3>üå≥ Tree</h3>
        <p>Cost: 50 coins</p>
        <p>Slows water flow</p>
        <button class="btn" data-structure="tree">Buy</button>
      </div>
      <div class="shop-item">
        <h3>üß± Basic Wall</h3>
        <p>Cost: 100 coins</p>
        <p>Small barrier</p>
        <button class="btn" data-structure="wall">Buy</button>
      </div>
      <div class="shop-item">
        <h3>üè∞ Strong Wall</h3>
        <p>Cost: 250 coins</p>
        <p>Tall and durable</p>
        <button class="btn" data-structure="strong">Buy</button>
      </div>
      <div class="shop-item">
        <h3>üóø Mega Barrier</h3>
        <p>Cost: 500 coins</p>
        <p>Maximum protection</p>
        <button class="btn" data-structure="mega">Buy</button>
      </div>
    </div>
    <p class="help-text">Click a defense type, then click on the terrain to build!</p>
    <div class="menu-buttons">
      <button class="btn" id="closeShopBtn">‚Üê Close Shop</button>
    </div>
  </div>

  <!-- Game Over Menu -->
  <div id="gameOverMenu" class="menu hidden">
    <h2>üíÄ CITY DESTROYED! üíÄ</h2>
    <p style="text-align: center; margin: 20px 0; font-size: 18px;">
      Your city was overwhelmed by the tsunami!
    </p>
    <p style="text-align: center;">
      <strong>Level Reached:</strong> <span id="finalLevel">1</span><br>
      <strong>Total Waves Survived:</strong> <span id="finalWaves">0</span>
    </p>
    <div class="menu-buttons">
      <button class="btn primary" id="restartBtn">üîÑ Try Again</button>
      <button class="btn" id="backToMenuBtn">‚Üê Main Menu</button>
    </div>
  </div>

  <!-- Victory Menu -->
  <div id="victoryMenu" class="menu hidden">
    <h2>üéâ WAVE SURVIVED! üéâ</h2>
    <p style="text-align: center; margin: 20px 0; font-size: 18px;">
      Your defenses held strong!
    </p>
    <p style="text-align: center;">
      <strong>Reward:</strong> <span id="rewardCoins">0</span> coins üí∞
    </p>
    <div class="menu-buttons">
      <button class="btn success" id="nextLevelBtn">‚û°Ô∏è Next Level</button>
      <button class="btn" id="continueBtn">Continue Building</button>
    </div>
  </div>

  <script>
    // Game Configuration
    const CONFIG = {
      defenseTypes: {
        tree: { cost: 50, hp: 30, height: 40, width: 15, color: '#2d5016', icon: 'üå≥' },
        wall: { cost: 100, hp: 100, height: 60, width: 20, color: '#8b4513', icon: 'üß±' },
        strong: { cost: 250, hp: 250, height: 100, width: 25, color: '#696969', icon: 'üè∞' },
        mega: { cost: 500, hp: 500, height: 150, width: 30, color: '#4a4a4a', icon: 'üóø' }
      }
    };

    // Game State
    class Game {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();

        this.state = 'menu'; // menu, playing, paused, gameover
        this.level = 1;
        this.coins = 500;
        this.cityHp = 100;
        this.maxCityHp = 100;
        this.waveActive = false;
        this.waveNumber = 0;
        this.selectedDefense = null;
        this.defenses = [];
        this.particles = [];
        this.waterParticles = [];

        this.groundY = this.canvas.height * 0.7;
        this.cityX = this.canvas.width * 0.85;
        this.cityWidth = this.canvas.width * 0.15;

        this.tsunami = {
          active: false,
          x: -500,
          height: 0,
          speed: 0,
          particles: []
        };

        this.setupEventListeners();
        this.loadGame();
        this.lastTime = performance.now();
        this.animate();
      }

      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.groundY = this.canvas.height * 0.7;
        this.cityX = this.canvas.width * 0.85;
        this.cityWidth = this.canvas.width * 0.15;
      }

      setupEventListeners() {
        window.addEventListener('resize', () => this.resize());

        this.canvas.addEventListener('click', (e) => this.handleClick(e));

        document.getElementById('startGameBtn').addEventListener('click', () => this.startGame());
        document.getElementById('howToPlayBtn').addEventListener('click', () => this.showHowToPlay());
        document.getElementById('backToMainBtn').addEventListener('click', () => this.showMainMenu());
        document.getElementById('shopBtn').addEventListener('click', () => this.showShop());
        document.getElementById('closeShopBtn').addEventListener('click', () => this.closeShop());
        document.getElementById('startWaveBtn').addEventListener('click', () => this.startWave());
        document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
        document.getElementById('resetBtn').addEventListener('click', () => this.resetLevel());
        document.getElementById('restartBtn').addEventListener('click', () => this.startGame());
        document.getElementById('backToMenuBtn').addEventListener('click', () => this.showMainMenu());
        document.getElementById('nextLevelBtn').addEventListener('click', () => this.nextLevel());
        document.getElementById('continueBtn').addEventListener('click', () => this.closeVictory());

        // Shop item buttons
        document.querySelectorAll('[data-structure]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const type = e.target.dataset.structure;
            this.selectDefense(type);
          });
        });
      }

      handleClick(e) {
        if (this.state !== 'playing' || this.waveActive) return;
        if (!this.selectedDefense) return;

        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Check if clicking on ground area (not city)
        if (y >= this.groundY - 200 && y <= this.groundY && x < this.cityX) {
          this.placeDefense(x);
        }
      }

      selectDefense(type) {
        const def = CONFIG.defenseTypes[type];
        if (this.coins >= def.cost) {
          this.selectedDefense = type;
          this.closeShop();
        } else {
          alert('Not enough coins!');
        }
      }

      placeDefense(x) {
        const type = this.selectedDefense;
        const def = CONFIG.defenseTypes[type];

        if (this.coins >= def.cost) {
          this.defenses.push({
            type,
            x: x,
            y: this.groundY - def.height,
            hp: def.hp,
            maxHp: def.hp,
            width: def.width,
            height: def.height,
            color: def.color,
            icon: def.icon
          });

          this.coins -= def.cost;
          this.selectedDefense = null;
          this.updateUI();
          this.saveGame();
        }
      }

      startGame() {
        this.state = 'playing';
        this.level = 1;
        this.coins = 500;
        this.cityHp = 100;
        this.waveNumber = 0;
        this.defenses = [];
        this.tsunami = { active: false, x: -500, height: 0, speed: 0, particles: [] };
        this.hideAllMenus();
        this.updateUI();
        this.saveGame();
      }

      startWave() {
        if (this.waveActive) return;

        this.waveActive = true;
        this.waveNumber++;

        // Show warning
        document.getElementById('waveWarning').classList.remove('hidden');
        setTimeout(() => {
          document.getElementById('waveWarning').classList.add('hidden');
          this.spawnTsunami();
        }, 2000);

        this.updateUI();
      }

      spawnTsunami() {
        const baseHeight = 80 + (this.level * 15) + (this.waveNumber * 10);
        const baseSpeed = 2 + (this.level * 0.3) + (this.waveNumber * 0.2);

        this.tsunami = {
          active: true,
          x: -200,
          height: baseHeight,
          speed: baseSpeed,
          particles: []
        };
      }

      updateTsunami(deltaTime) {
        if (!this.tsunami.active) return;

        // Move tsunami
        this.tsunami.x += this.tsunami.speed;

        // Create water particles
        if (Math.random() < 0.3) {
          this.tsunami.particles.push({
            x: this.tsunami.x + Math.random() * 100,
            y: this.groundY - this.tsunami.height - Math.random() * 30,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            life: 1
          });
        }

        // Update particles
        this.tsunami.particles = this.tsunami.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.01;
          return p.life > 0;
        });

        // Check collision with defenses
        this.defenses = this.defenses.filter(def => {
          if (this.tsunami.x >= def.x - 20 && this.tsunami.x <= def.x + def.width + 20) {
            const damage = this.tsunami.speed * 2;
            def.hp -= damage;

            // Create impact particles
            for (let i = 0; i < 5; i++) {
              this.particles.push({
                x: def.x + def.width / 2,
                y: def.y + Math.random() * def.height,
                vx: (Math.random() - 0.5) * 4,
                vy: -Math.random() * 3,
                color: '#fff',
                life: 1
              });
            }

            // Slow down tsunami
            this.tsunami.speed *= 0.95;
            this.tsunami.height *= 0.98;

            return def.hp > 0;
          }
          return true;
        });

        // Check if reached city
        if (this.tsunami.x >= this.cityX) {
          const damage = this.tsunami.speed * 0.5;
          this.cityHp -= damage;
          this.cityHp = Math.max(0, this.cityHp);

          if (this.cityHp <= 0) {
            this.gameOver();
          }
        }

        // Wave passes off screen
        if (this.tsunami.x > this.canvas.width + 200) {
          this.waveComplete();
        }

        this.updateUI();
      }

      waveComplete() {
        this.tsunami.active = false;
        this.waveActive = false;

        // Calculate reward
        const reward = 100 + (this.level * 50) + (this.waveNumber * 25);
        this.coins += reward;

        document.getElementById('rewardCoins').textContent = reward;
        document.getElementById('victoryMenu').classList.remove('hidden');

        this.updateUI();
        this.saveGame();
      }

      nextLevel() {
        this.level++;
        this.cityHp = Math.min(this.maxCityHp, this.cityHp + 20); // Heal a bit
        this.closeVictory();
        this.updateUI();
        this.saveGame();
      }

      gameOver() {
        this.state = 'gameover';
        this.tsunami.active = false;
        this.waveActive = false;

        document.getElementById('finalLevel').textContent = this.level;
        document.getElementById('finalWaves').textContent = this.waveNumber;
        document.getElementById('gameOverMenu').classList.remove('hidden');

        // Clear saved game
        localStorage.removeItem('tsunamiDefense');
      }

      resetLevel() {
        if (confirm('Reset current level? You will lose all defenses but keep your coins.')) {
          this.defenses = [];
          this.tsunami = { active: false, x: -500, height: 0, speed: 0, particles: [] };
          this.waveActive = false;
          this.cityHp = this.maxCityHp;
          this.updateUI();
          this.saveGame();
        }
      }

      togglePause() {
        if (this.state === 'playing') {
          this.state = 'paused';
          document.getElementById('pauseBtn').textContent = '‚ñ∂Ô∏è Resume';
        } else if (this.state === 'paused') {
          this.state = 'playing';
          document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
        }
      }

      showMainMenu() {
        this.hideAllMenus();
        document.getElementById('mainMenu').classList.remove('hidden');
        this.state = 'menu';
      }

      showHowToPlay() {
        this.hideAllMenus();
        document.getElementById('howToPlayMenu').classList.remove('hidden');
      }

      showShop() {
        document.getElementById('shopMenu').classList.remove('hidden');
      }

      closeShop() {
        document.getElementById('shopMenu').classList.add('hidden');
      }

      closeVictory() {
        document.getElementById('victoryMenu').classList.add('hidden');
      }

      hideAllMenus() {
        document.querySelectorAll('.menu').forEach(menu => menu.classList.add('hidden'));
      }

      updateUI() {
        document.getElementById('levelDisplay').textContent = this.level;
        document.getElementById('coinsDisplay').textContent = this.coins;
        document.getElementById('cityHpDisplay').textContent = Math.ceil(this.cityHp);

        const waveStatus = this.waveActive ?
          (this.tsunami.active ? `Active #${this.waveNumber}` : 'Incoming...') :
          'Ready';
        document.getElementById('waveDisplay').textContent = waveStatus;

        document.getElementById('startWaveBtn').disabled = this.waveActive;
      }

      saveGame() {
        const saveData = {
          level: this.level,
          coins: this.coins,
          cityHp: this.cityHp,
          waveNumber: this.waveNumber,
          defenses: this.defenses
        };
        localStorage.setItem('tsunamiDefense', JSON.stringify(saveData));
      }

      loadGame() {
        const saved = localStorage.getItem('tsunamiDefense');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            this.level = data.level || 1;
            this.coins = data.coins || 500;
            this.cityHp = data.cityHp || 100;
            this.waveNumber = data.waveNumber || 0;
            this.defenses = data.defenses || [];
          } catch (e) {
            console.error('Failed to load save:', e);
          }
        }
      }

      // Rendering
      render() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;

        // Sky
        const gradient = ctx.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, '#87ceeb');
        gradient.addColorStop(1, '#e0f6ff');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);

        // Ocean
        ctx.fillStyle = '#1e90ff';
        ctx.fillRect(0, this.groundY, w, h - this.groundY);

        // Ocean waves (decorative)
        ctx.fillStyle = '#4169e1';
        for (let i = 0; i < 5; i++) {
          const offset = (performance.now() / 1000 + i * 50) % (w + 100);
          ctx.beginPath();
          ctx.arc(offset - 50, this.groundY + 10, 30, 0, Math.PI, true);
          ctx.fill();
        }

        // Ground/Beach
        ctx.fillStyle = '#c2b280';
        ctx.fillRect(0, this.groundY, w, 30);

        // City
        this.renderCity();

        // Defenses
        this.defenses.forEach(def => this.renderDefense(def));

        // Tsunami
        if (this.tsunami.active) {
          this.renderTsunami();
        }

        // Particles
        this.particles.forEach(p => this.renderParticle(p));

        // Selection indicator
        if (this.selectedDefense && this.state === 'playing' && !this.waveActive) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.font = '24px Arial';
          ctx.fillText('Click to place ' + CONFIG.defenseTypes[this.selectedDefense].icon, w/2 - 100, 40);
        }
      }

      renderCity() {
        const ctx = this.ctx;
        const x = this.cityX;
        const y = this.groundY;

        // Buildings
        const buildings = [
          { x: x, w: 40, h: 120, color: '#808080' },
          { x: x + 45, w: 35, h: 90, color: '#696969' },
          { x: x + 85, w: 45, h: 140, color: '#778899' },
          { x: x + 135, w: 40, h: 100, color: '#708090' }
        ];

        buildings.forEach(b => {
          // Building
          ctx.fillStyle = b.color;
          ctx.fillRect(b.x, y - b.h, b.w, b.h);

          // Windows
          ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
          for (let wy = y - b.h + 10; wy < y - 10; wy += 20) {
            for (let wx = b.x + 5; wx < b.x + b.w - 5; wx += 12) {
              ctx.fillRect(wx, wy, 8, 12);
            }
          }
        });

        // HP Bar
        const barWidth = this.cityWidth;
        const barHeight = 15;
        const barX = x;
        const barY = y - 170;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        const hpPercent = this.cityHp / this.maxCityHp;
        ctx.fillStyle = hpPercent > 0.5 ? '#4ade80' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
      }

      renderDefense(def) {
        const ctx = this.ctx;

        // Structure
        ctx.fillStyle = def.color;
        ctx.fillRect(def.x, def.y, def.width, def.height);

        // Border
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect(def.x, def.y, def.width, def.height);

        // Icon
        ctx.font = '20px Arial';
        ctx.fillText(def.icon, def.x + def.width/2 - 10, def.y + 20);

        // HP Bar
        if (def.hp < def.maxHp) {
          const hpPercent = def.hp / def.maxHp;
          const barW = def.width;
          const barH = 5;

          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(def.x, def.y - 10, barW, barH);

          ctx.fillStyle = hpPercent > 0.5 ? '#4ade80' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
          ctx.fillRect(def.x, def.y - 10, barW * hpPercent, barH);
        }
      }

      renderTsunami() {
        const ctx = this.ctx;
        const x = this.tsunami.x;
        const h = this.tsunami.height;
        const y = this.groundY;

        // Main wave body
        const waveGradient = ctx.createLinearGradient(x, y - h, x, y);
        waveGradient.addColorStop(0, 'rgba(70, 130, 180, 0.8)');
        waveGradient.addColorStop(0.5, 'rgba(30, 144, 255, 0.9)');
        waveGradient.addColorStop(1, 'rgba(0, 100, 200, 0.95)');

        ctx.fillStyle = waveGradient;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y - h);

        // Wavy top
        for (let i = 0; i <= 100; i += 10) {
          const waveX = x + i;
          const waveY = y - h + Math.sin((x + i) * 0.05 + performance.now() / 200) * 15;
          ctx.lineTo(waveX, waveY);
        }

        ctx.lineTo(x + 100, y);
        ctx.closePath();
        ctx.fill();

        // Foam
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        for (let i = 0; i < 10; i++) {
          const foamX = x + Math.random() * 100;
          const foamY = y - h + Math.random() * 20;
          ctx.beginPath();
          ctx.arc(foamX, foamY, Math.random() * 5 + 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // Particles
        this.tsunami.particles.forEach(p => {
          ctx.fillStyle = `rgba(100, 180, 255, ${p.life})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      renderParticle(p) {
        const ctx = this.ctx;
        ctx.fillStyle = p.color || `rgba(255, 255, 255, ${p.life})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      update(deltaTime) {
        if (this.state !== 'playing') return;

        // Update tsunami
        if (this.tsunami.active) {
          this.updateTsunami(deltaTime);
        }

        // Update particles
        this.particles = this.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.2; // gravity
          p.life -= 0.02;
          return p.life > 0 && p.y < this.canvas.height;
        });
      }

      animate() {
        const now = performance.now();
        const deltaTime = (now - this.lastTime) / 1000;
        this.lastTime = now;

        this.update(deltaTime);
        this.render();

        requestAnimationFrame(() => this.animate());
      }
    }

    // Initialize game
    const game = new Game();

    // Register Service Worker for PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js')
          .then(reg => console.log('Service Worker registered:', reg))
          .catch(err => console.log('Service Worker registration failed:', err));
      });
    }
  </script>
</body>
</html>
